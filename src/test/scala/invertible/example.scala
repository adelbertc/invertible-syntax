/*
 * Copyright 2014 - 2015 SlamData Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package invertible

import scalaz._, Scalaz._

import invertible._

/** Dummy functor-ized AST representing a subset of JavaScript expressions.
  * Using a functor for the AST allows the syntax to decorate the nodes with
  * the source location of each node.
  */
sealed trait Expr[+A]
object Expr {
  case object Null extends Expr[Nothing]
  final case class Bool(value: Boolean) extends Expr[Nothing]
  final case class Num(value: Int) extends Expr[Nothing]
  final case class BinOp[A](op: BinaryOperator, l: A, r: A) extends Expr[A]

  abstract sealed class BinaryOperator(val js: String)
  case object Add extends BinaryOperator("+")
  case object BitAnd extends BinaryOperator("&")
  case object BitLShift extends BinaryOperator("<<")
  case object BitNot extends BinaryOperator("~")
  case object BitOr  extends BinaryOperator("|")
  case object BitRShift extends BinaryOperator(">>")
  case object BitXor  extends BinaryOperator("^")
  case object Lt extends BinaryOperator("<")
  case object Lte extends BinaryOperator("<=")
  case object Gt extends BinaryOperator(">")
  case object Gte extends BinaryOperator(">=")
  case object Eq extends BinaryOperator("===")
  case object Neq extends BinaryOperator("!==")
  case object Div extends BinaryOperator("/")
  case object In extends BinaryOperator("in")
  case object And extends BinaryOperator("&&")
  case object Or extends BinaryOperator("||")
  case object Mod extends BinaryOperator("%")
  case object Mult extends BinaryOperator("*")
  case object Sub extends BinaryOperator("-")
}

object ExprConstructors {
  import Iso._
  import Expr._

  // Lift each constructor into an Iso. NB: these are entirely mechanical
  // and could/should be generated by a macro or derived from something
  // monocle can generate.

  def exprNull[A] = element[Expr[A]](Null)
  def exprBool[A] = iso[Boolean, Expr[A]](
    { case x => Bool(x) },
    { case Bool(x) => x })
  def exprNum[A] = iso[Int, Expr[A]](
    { case x => Num(x) },
    { case Num(x) => x } )

  // NB: not used because infix ops get special treatment below
  def exprBinOp[A] = iso[(BinaryOperator, A, A), Expr[A]](
    { case (op, l, r) => BinOp(op, l, r) },
    { case BinOp(op, l, r) => (op, l, r) })
}

object ExprSyntax {
  import Iso._
  import Syntax._
  import ExprConstructors._

  type P[F[_]] = Cofree[F, Pos]
  type T = P[Expr]

  def syntax[F[_]](syntax: Syntax[F]): F[Cofree[Expr, Pos]] = {
    import Iso._
    import Syntax._
    import ExprConstructors._
    import Expr._

    implicit val S = syntax

    def parens(f: F[T]): F[T] = {
      val p = text("(") *> f <* text(")")
      // recapture the position to include the parens, which don't get a node of their own.
      fix <> S.pos(unPos(p))
    }

    def fix = Iso.total[(Expr[T], Pos), T](
      { case (js, pos) => Cofree(pos, js) },
      v => (v.tail, v.head))

    // This is effectively the inverse of `fix <> S.pos(p)`
    // NB: the original Pos is discarded, so it has to be synthesized
    // when un-parsing, but of course we don't care, so just using
    // `null` here. A cleaner approach would combine uwrapping and
    // re-wrapping so that the actual Pos would be available.
    def unPos(p: F[T]) = unit.inverse <> (second(ignore[Pos](null)) <> (fix.inverse <> p))

    def nullP = fix <> S.pos(exprNull[T] <> text("null"))
    def trueP  = fix <> S.pos((element(true) >>> exprBool[T]) <> text("true"))
    def falseP = fix <> S.pos((element(false) >>> exprBool[T]) <> text("false"))

    def numP = {
      val toInt = Iso.total[List[Char], Int](
        _.mkString.toInt,
        _.toString.toList)
      fix <> S.pos((toInt >>> exprNum[T]) <> many1(digit))
    }

    def infixl(f0: F[T], ops: BinaryOperator*): F[T] = {
      val fOps = {
        def binOp(op: BinaryOperator): F[BinaryOperator] = element(op) <> text(op.js)
        ops.map(binOp).reduce(_ <|> _)
      }

      val flatten = Iso.total[(T, List[(BinaryOperator, T)]), T](
        {
          case (x1, ts) =>
            ts.foldLeft(x1) {
              // NB: accumulating positions by inspecting the sub-terms,
              // which seems like a hack. Where would we wrap with `S.pos`
              // to capture the position directly?
              case (acc @ Cofree((s1, _), _), (op, x @ Cofree((_, e2), _))) =>
                Cofree((s1, e2), BinOp(op, acc, x))
            }
        },
        x => {
          def loop(x: T): (T, List[(BinaryOperator, T)]) = x match {
            case Cofree(_, BinOp(op, l, r)) if ops contains op =>
              val (lh, lt) = loop(l)
              lh -> (lt ++ List(op -> r))
            case _ => x -> Nil
          }
          loop(x)
        })

      flatten <> (f0 <*> many((optSpace *> fOps <* optSpace) <*> f0))
    }

    def infix0 = nullP <|> trueP <|> falseP <|> numP <|>
        parens(skipSpace *> infix11 <* skipSpace)
    def infix1  = infixl(infix0, Mult, Div, Mod)
    def infix2  = infixl(infix1, Add, Sub)
    def infix3  = infixl(infix2, BitLShift, BitRShift)  // omitted: >>>
    def infix4  = infixl(infix3, Lt, Lte, Gt, Gte, In)  // omitted: instanceof
    def infix5  = infixl(infix4, Eq, Neq)  // omitted: ==, !=
    def infix6  = infixl(infix5, BitAnd)
    def infix7  = infixl(infix6, BitXor)
    def infix8  = infixl(infix7, BitOr)
    def infix9  = infixl(infix8, And)
    def infix10 = infixl(infix9, Or)
    // omitted: all assignment ops: "=", "*=", "/=", "%=", "+=", "-=", "<<=", ">>=", ">>>=", "&=", "^=", "|="
    lazy val infix11: F[T] = infix10

    def js = skipSpace *> infix11 <* skipSpace

    js
  }

  val ExprParser = syntax(Syntax.ParserSyntax)
  val ExprPrinter = syntax(Syntax.PrinterSyntax)
}

object Test extends App {
  import ExprSyntax._

  val examples = List(
    "",
    "null",
    " null ",
    "123",
    " 123 ",
    // "1+2",
    // "1 + 2",
    "1 + 2 + 3",
    // "(1+2)+3",  // Left-recursive, so equivalent to previous
    // "1+(2+3)",  // Not left-recursive, so the parens are not removed (preserving eval. order)
    // "1 - 2",
    // "1 - 2 + 3",
    // "1 - (2 + 3)",
    // "1 * 2",
    "(1 + 2) * 3",
    " 1+( 2*3 ) ",
    // "true",
    "   true ",
    // "false",
    // "1 < 2",
    "(1 < 2) && true",  // For some reason this parses two ways, with the same result.
    // "2 ^ 3 & 4 || 5 >> 7 <= 8 in 9",  // ~20s to parse this one! (not any more)

    // errors:
    "1 + )",

    "")

  def toTree(v: Cofree[Expr, Syntax.Pos]): Tree[String] = v match {
    case Cofree(pos, Expr.Null) => scalaz.Tree.leaf("null " + pos)
    case Cofree(pos, Expr.Bool(true)) => scalaz.Tree.leaf("true " + pos)
    case Cofree(pos, Expr.Bool(false)) => scalaz.Tree.leaf("false " + pos)
    case Cofree(pos, Expr.Num(x)) => scalaz.Tree.leaf(x + " " + pos)
    case Cofree(pos, Expr.BinOp(op, l, r)) =>
      scalaz.Tree.node(op + " " + pos,
        toTree(l) #:: toTree(r) #:: Stream.empty)
  }

  examples.foreach { src =>
    println("\"" + src + "\"")
    ExprParser.parse(src).map(_.fold(
      err => (),
      // err => println(err),
      expr => {
        println(toTree(expr).drawTree)
        val p = ExprPrinter.print(expr)
        println("--> " + p.map("\"" + _ + "\"").getOrElse(""))
      }))
    println("")
  }
}
